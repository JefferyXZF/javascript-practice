<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>

    // 变量、作用域与内存
    // 原始值与引用值
    // 原始值：原始值大小固定，因此保存在栈内存上，从一个变量到另一个变量复制原始值会创建该值的第二个副本。

    // 引用值：引用值是对象，存储在堆内存上。包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。


    // 变量有按值和按引用访问，而传参则只有按值传递。

    function setName(obj) {
      obj.name = 'zhangsan'
      obj = new Object()
      obj.name = 'lisi'
    }

    const person = new Object()
    setName(person)
    console.log(person.name) // zhangsan，如果是按引用则为lisi，实际情况为zhangsan

    // 数据类型检测：typeof(基本类型)、instanceof(引用类型)、toString(通用)


    // 执行上下文与作用域
    // 执行上下文分全局上下文、函数上下文和块级上下文
    // 代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。
    // 函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。
    // 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。
    // 变量的执行上下文用于确定什么时候释放内存。


    // 垃圾回收：标记清理和引用计数
    // 标记清理：当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。当变量离开上下文时，也会被加上离开上下文的标记。

    // 引用计数：对每个值都记录它被引用的次数；当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。它会有循环引用的问题

    // 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。
    // 主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。
    // 引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript引擎不再使用这种算法，但某些旧版本的IE仍然会受这种算法的影响，原因是JavaScript会访问非原生JavaScript对象（如DOM元素）。
    // 引用计数在代码中存在循环引用时会出现问题。
    
    // 解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。



    // 内存管理：解除引用，释放内存
    // 内存泄露：闭包函数、全局属性



  </script>
</body>
</html>