<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
  <script>
    // 对象
    // 数据属性：configurable、enumerable、value、writable
    // 访问器属性: configurable、enumerable、get、set

    // 方法
    // Object.defineProperty、Object.defineProperties、Object.getOwnPropertyDescriptor、Object.assign、hasOwnProperty、Object.keys、Object.values()、Object.entries、Object.getOwnPropertyNames(包含不可枚举属性，例如 constructor)
    // Object.getOwnPropertySymbols

    // 类声明
    class Person {}
    // 类表达式
    const Person = class {}

    // new调用类的构造函数会执行如下操作
    // （1）在内存中创建一个新对象。
    // （2）这个新对象内部的[[Prototype]]指针被赋值为构造函数的prototype属性。
    // （3）构造函数内部的this被赋值为这个新对象（即this指向新对象）
    // （4）执行构造函数内部的代码（给新对象添加属性）
    // （5）如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象

    // 继承
    // 原型式继承可以无须明确定义构造函数而实现继承，本质上是对给定对象执行浅复制。这种操作的结果之后还可以再进一步增强
    // 与原型式继承紧密相关的是寄生式继承，即先基于一个对象创建一个新对象，然后再增强这个新对象，最后返回新对象。这个模式也被用在组合继承中，用于避免重复调用父类构造函数导致的浪费。
    // 寄生组合继承被认为是实现基于类型继承的最有效方式
    
    // 目前最流行的继承模式是组合继承，即通过原型链继承共享的属性和方法，通过盗用构造函数继承实例属性。

  </script>
</body>
</html>